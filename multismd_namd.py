"""Script for setting up multi-directional SMD simulations in NAMD.

This script generates all necessary input files and the directory structure
for a series of Steered Molecular Dynamics (SMD) simulations. The simulations
are set up to pull a selection of atoms along a set of vectors that
roughly cover a hemisphere, with each simulation's data stored in a
separate directory.

To run this script, the following Python libraries are required:
  - numpy
  - scipy
  - MDAnalysis

Author: Katarzyna Walczewska-Szewc
Affiliation: Nicolaus Copernicus University in ToruÅ„
Date: 2024-2025
"""
import argparse
from pathlib import Path
from typing import Any
import numpy as np
from MDAnalysis import *
from numpy import *
from scipy.spatial.transform import Rotation
import os
from zipfile import ZipFile

# Default name of output directory
output_directory = 'Output'


def construct_hedgehog(pdb: str, fix_selection: str, pull_selection: str) -> Any:
    """
    Generates a set of sampling vectors, commonly called a "hedgehog"
    aligned in a specific direction defined by two selections of atoms in a PDB file.

    Parameters:
    - pdb (str): The path to the PDB file.
    - fix_selection (str): The atom selection criteria for the "fixed" group.
    - pull_selection (str): The atom selection criteria for the "pulled" group.

    Returns:
    - hedgehog (numpy.ndarray): An array of vectors (N, 3) that sample the hemisphere.
    - labels (numpy.ndarray): An array of labels (N, 2) containing the spherical
      coordinates [theta, phi] for each vector.
    - pull_com (numpy.ndarray): The [x, y, z] coordinates of the center of mass
      of the "pulled" group.
    """
    u = Universe(pdb)
    fix_com = u.select_atoms(fix_selection).center_of_mass()
    pull_com = u.select_atoms(pull_selection).center_of_mass()

    # Define the principal axis
    ax_principal = pull_com - fix_com
    ax_principal_unit = ax_principal / linalg.norm(ax_principal)

    print(f"Principal axis unit vector: {ax_principal_unit}")

    # Generating a "hedgehog" of vectors in z-direction
    hedgehog = array([[0,0,1]])
    labels = array([[0, 0]])
    for theta,resolution in zip([45,90],[90,90]):#[15,30,45,60,75,90],[90,75,60,45,30,15]):
        for phi in range(0,360,resolution):
            x = cos(deg2rad(phi))*sin(deg2rad(theta))
            y = sin(deg2rad(phi))*sin(deg2rad(theta))
            z = cos(deg2rad(theta))

            hedgehog = concatenate((hedgehog,array([[x,y,z]])),axis=0)
            # Labels for subdirectories names construction
            labels = concatenate((labels,array([[theta,phi]])),axis=0)

    # Transforming the vector cone to the direction given by the principal axis
    r = Rotation.align_vectors([ax_principal_unit],[[0,0,1]])
    hedgehog = r[0].apply(hedgehog)
    # The translation of the cone's anchor to the COM of the pulled protein is not
    # necessary because NAMD handles it automatically.

    # Set of vectors [N][x,y,z], set of angles [N][theta,phi], the pulling point [x,y,z]
    return hedgehog, labels, pull_com



def generate_input(name, pdb, psf, vectors, template, sel1, sel2, par1, coor=None, vel=None, xsc=None, n_repeats=1):
    """
    Sets up the directory structure and input files for a series of steered
    molecular dynamics (SMD) simulations.

    The function creates a main output directory and subdirectories for each
    SMD pulling direction. It copies necessary structure and restart files,
    generates a constraints PDB file, and modifies a template NAMD input file
    for each simulation run.

    Generated output directory structure:
    name/ - the output directory containing all generated files, copy of the NAMD input structures and the simulation results
        SMD_constraints.pdb - the output file containing information about fixed and pulled atoms for SMD (O and B colum, respectively)
        SMD_theta_i_phi_j/ - subdirectories for each SMD direction run (the simulation output will be stored here)
        mdrun.inp - input file for a single SMD simulation
        vmd_script.tcl - the vmd script to visualize the cone of vectors

    Parameters:
    - name (str): The name of the main output directory.
    - pdb (str): Path to the PDB file.
    - psf (str): Path to the PSF file.
    - vectors (tuple): A tuple containing a numpy array of vectors and a numpy
      array of corresponding spherical coordinate labels, as generated by
      the `construct_hedgehog` function.
    - template (str): Path to the template NAMD input file (`.inp`).
    - sel1 (str): Atom selection criteria for the fixed group.
    - sel2 (str): Atom selection criteria for the pulled group.
    - par1 (str): Path to the parameter file or a toppar.zip file.
    - coor (str, optional): Path to the coordinate restart file. Defaults to None.
    - vel (str, optional): Path to the velocity restart file. Defaults to None.
    - xsc (str, optional): Path to the extended system restart file. Defaults to None.
    """
    
    # Create the main output directory and copy necessary structure files
    os.system('mkdir '+str(name))
    os.system('cp '+str(pdb)+' '+str(name)+'/')
    os.system('cp '+str(psf)+' '+str(name)+'/')

    # Handle parameter files: unzip if it's a toppar.zip, otherwise copy
    if str(par1)[-10:] =='toppar.zip': 
        with ZipFile(par1,'r') as z:
            z.extractall(str(name)+'/')
    if str(par1)[-10:] != 'toppar.zip': os.system('cp -r '+str(par1)+' '+str(name)+'/')

    # Copy optional restart files if provided
    if coor:
        os.system('cp '+str(coor)+' '+str(name)+'/')
    if vel:
        os.system('cp '+str(vel)+' '+str(name)+'/')
    if xsc:
        os.system('cp '+str(xsc)+' '+str(name)+'/')

    # Create SMD_constraints.pdb file with flags in the B-factor (tempfactors)
    # and Occupancy (occupancies) columns to mark fixed and pulled atoms.
    u = Universe(pdb)
    all_atoms = u.select_atoms('all')
    all_atoms.occupancies = [0 for _ in range(len(all_atoms.occupancies))]
    all_atoms.tempfactors = [0 for _ in range(len(all_atoms.occupancies))]

    fix_atoms = u.select_atoms(sel1)
    fix_atoms.tempfactors = [1 for _ in range(len(fix_atoms.tempfactors))]
    pul = u.select_atoms(sel2)
    pul.occupancies = [1 for _ in range(len(pul.occupancies))]
    all_atoms.write(str(name) + '/SMD_constraints.pdb')

    # Create subdirectories for each direction in the hemisphere
    for v,l in zip(vectors[0],vectors[1]):
        # Create a directory for each theta-phi combination
        os.system('mkdir '+str(name)+'/SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1])))

        # Loop to create multiple simulation repeats
        for n in range(0,n_repeats):
                f = open(template,'r')

                # Several repeats of simulation are produced
                new_f= open(f'{name}/SMD_theta_{int(l[0])}_phi_{int(l[1])}/mdrun{n}.inp','w')

                # Changing information about the structure and parameters
                new_f.write('structure	../'+str(psf.split('/')[-1])+'\n')
                new_f.write('coordinates	../'+str(pdb.split('/')[-1])+'\n')
                if coor: new_f.write('bincoordinates	../'+str(coor.split('/')[-1])+'\n')
                if vel: new_f.write('binvelocities	../'+str(vel.split('/')[-1])+'\n')
                if xsc: new_f.write('extendedSystem	../'+str(xsc.split('/')[-1])+'\n')
                new_f.write('paratypecharmm	on\n')
                if par1[-10:] =='toppar.zip':
                    for filename in os.listdir(str(name)+'/toppar'):
                        new_f.write('parameters	../toppar/'+str(filename)+'\n')
                if par1[-10:]!='toppar.zip':
                    new_f.write('parameters ../'+str(par1.split('/')[-1])+'\n')

                for line in f.readlines():
                    if line[0:7].lower() != 'structu' and line[0:7].lower() != 'coordin' and line[0:7].lower() != 'bincoor' and line[0:7].lower() != 'binvelo' and line[0:7].lower() != 'extende' and line[0:7].lower() != 'paramet' and line[0:7].lower() != 'paratyp':
                      line_new = line
                      if line[0:10] == 'outputname': line_new = f'outputname      md{n}\n'
                      if line[0:7] == 'SMDfile': line_new = 'SMDfile ../SMD_constraints.pdb'+'\n' #The files common for each SMD_run are stored in the output directory
                      if line[0:6] == 'SMDDir': line_new = 'SMDDir	'+str(v[0])+' '+str(v[1])+' '+str(v[2])+'\n'
                      if line[0:7] == 'consref': line_new = 'consref ../SMD_constraints.pdb'+'\n'
                      if line[0:10] == 'conskfile ': line_new = 'conskfile ../SMD_constraints.pdb'+'\n'
                      new_f.write(line_new)
                new_f.close()
                f.close()


def generate_bash_run_scripts(name: str, label: np.ndarray, template: str, n_repeats: int = 1) -> None:
    """
    Generates and populates a master run script and individual bash scripts for
    each SMD simulation, based on a template.

    The function creates a `master.run` file to manage all simulation runs and
    generates a unique `run.bash` script for each pulling direction and repeat.
    The template script is modified to include the correct job name, input file path,
    and output log file path.

    Parameters:
    - name (str): The name of the main output directory.
    - label (numpy.ndarray): An array of labels (N, 2) containing the spherical
      coordinates [theta, phi] for each vector, as generated by `construct_hedgehog`.
    - template (str): Path to the template bash script file (`.bash`).
    """

    # Create the master run file to control all simulations
    master_file = open(str(name)+'/master.run','w')
    for l in label:
        # Generate a run.bash file for each simulation repeat
        for n in range(0,n_repeats):
            # Open the template and the new file for writing
            f = open(template,'r')
            new_f= open(str(name)+'/SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+f'/run{n}.bash','w')
            for line in f.readlines():
                line_new = line
                if len(line.split())>1 and line.split()[1] == '-J': line_new = line.split()[0] + ' ' + line.split()[1] +' SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+'\n'

                if len(line.split())>1 and line.split()[1][0:4] == 'INPF': line_new = 'set INPF=SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+f'/mdrun{n}.inp'+'\n'
                if line[0:4] == 'INPF': line_new = f'INPF=mdrun{n}.inp'+'\n'
                if line[0:4] == 'OUTF': line_new = f'OUTF=mdrun{n}.log'+'\n'

                if len(line.split())>1 and line.split()[1][0:4] == 'OUTF': line_new = 'set OUTF=SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+f'/mdrun{n}.log'+'\n'
                new_f.write(line_new)
            new_f.close()

            # Running the simulations
            os.system('chmod +x '+str(name)+'/SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+f'/run{n}.bash')
            #os.system('. '+str(name)+'/SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+f'/run{n}.bash &') # If you are using this script on a supercomputer, all jobs can run simultanously
            master_file.write('. SMD_theta_'+str(int(l[0]))+'_phi_'+str(int(l[1]))+f'/run{n}.bash\n') # On a single gpu station, it could be better to run one job after one (the line without & at the end so the next job is waiting for the one to finish)
            f.close()

    # Close the master file
    master_file.close()

    # Make the master file executable
    os.system('chmod +x '+str(name)+'/master.run')
        

def generate_visualisation_script(name: str, vector: np.ndarray, com: np.ndarray) -> None:
    """
    Generates a Tcl script for VMD to visualize a set of pulling vectors as a
    cone, anchored at a specific center of mass.

    The script creates a custom VMD procedure for drawing arrows and then uses
    this procedure to draw each vector from the specified center of mass,
    scaling them for better visibility. The resulting script is saved to
    the main output directory.

    Parameters:
    - name (str): The name of the main output directory where the script will be saved.
    - vector (numpy.ndarray): A numpy array of 3D vectors. These vectors are
      typically the output from a function like `construct_hedgehog`.
    - com (numpy.ndarray): The 3D coordinates of the center of mass (e.g., of the
      pulled selection) to be used as the anchor point for the vectors.
    """

    # Use pathlib to create a path object for safe and clean file operations
    output_dir = Path(name)
    output_dir.mkdir(exist_ok=True)
    script_path = output_dir / 'vmd_script.tcl'
    # f = open(name+'/vmd_script.tcl','w')

    with open(script_path, 'w') as f:
        # Write a Tcl subroutine to draw an arrow. An arrow is constructed from a
        # cylinder and a cone for a visually distinct representation.
        f.write('proc vmd_draw_arrow {mol start end} {\n\t# an arrow is made of a cylinder and a cone\n\t set middle [vecadd $start [vecscale 0.9 [vecsub $end $start]]]\n\t graphics $mol cylinder $start $middle radius 0.15\n\t graphics $mol cone $middle $end radius 0.25\n}\n')

        s=5 # Scaling factor for the vectors to make them clearly visible in the visualization

        # Iterate through each vector to generate a drawing command
        for j in vector:
            i = j + com # The vectors need to be translated to the center of the mass of the protein and rescaled by the scaling factor (below)
            f.write('draw arrow {'+str(com[0])+' '+str(com[1])+' '+str(com[2])+'} {'+str(i[0]+(i[0]-com[0])*s)+' '+str(i[1]+(i[1]-com[1])*s)+' '+str(i[2]+(i[2]-com[2])*s)+'}\n' )


def main(args: argparse.Namespace):
    """
    Main function to orchestrate the generation of simulation files.

    This script sets up a directory structure and all necessary input files
    (NAMD, Bash, VMD) for a series of steered molecular dynamics (SMD) simulations.

    Parameters:
    - args (argparse.Namespace): The parsed command-line arguments.
    """

    # Step 1: Generate the set of vectors for the SMD pulling
    print('Generating the cone of vectors...')
    vectors, labels, pull_com = construct_hedgehog(args.input_pdb, args.sel1, args.sel2)
    hedgehog = (vectors, labels, pull_com)

    # Use pathlib for safe and clean directory creation
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Step 2: Set up the directory structure and create all NAMD input files
    print('Generating input files and directory structure...')
    generate_input(
        args.output_dir, args.input_pdb, args.input_psf, hedgehog, args.template_inp,
        args.sel1, args.sel2, args.input_par1,
        vel=args.input_vel, coor=args.input_coor, xsc=args.input_xsc,
        n_repeats=args.repeats
    )

    # Step 3: Generate the bash run scripts for each simulation
    print('Generating run scripts...')
    generate_bash_run_scripts(args.output_dir, labels, args.template_run, n_repeats=args.repeats)

    # Step 4: Generate the VMD visualization script
    print('Generating VMD visualization script...')
    generate_visualisation_script(args.output_dir, vectors, pull_com)

    print('Generation of SMD input finished!')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="""Generates input files and directory structure for a series of
            steered molecular dynamics (SMD) simulations - NAMD version."""
    )

    # Required simulation files
    parser.add_argument('output_dir', type=str,
                        help='The main output directory for all generated files.')
    parser.add_argument('input_pdb', type=str,
                        help='Path to the NAMD MD restart PDB file.')
    parser.add_argument('input_psf', type=str,
                        help='Path to the NAMD MD restart PSF file.')
    parser.add_argument('input_vel', type=str,
                        help='Path to the NAMD MD restart velocity file.')
    parser.add_argument('input_coor', type=str,
                        help='Path to the NAMD MD restart coordinate file.')
    parser.add_argument('input_xsc', type=str,
                        help='Path to the NAMD MD restart extended system file.')
    parser.add_argument('input_par1', type=str,
                        help='Path to the primary forcefield parameter file.')
    parser.add_argument('template_inp', type=str,
                        help='Path to the template NAMD input file (.inp).')
    parser.add_argument('template_run', type=str,
                        help='Path to the template bash run script (.run).')

    # Selection parameters for SMD
    parser.add_argument('sel1', type=str,
                        help='MDAnalysis selection criteria for the constrained atoms (fixed group).')
    parser.add_argument('sel2', type=str,
                        help='MDAnalysis selection criteria for the pulled atoms (pulled group).')
    parser.add_argument('--repeats', type=int, default=1,
                        help='Number of simulation repeats for each pulling direction (default: 1).')

    args = parser.parse_args()
    main(args)
